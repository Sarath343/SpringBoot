dcsc

return ResponseEntity to set a new response

So many logs coming in the broser means dev tools are enabled.
Once dev tooils are disabled only few lines of errors will come 
In production devtools will be disabled by default.(even if dont comment in pom file)


To throw exception:
	throw new exceptioName() ; 
	in this exceptionname class @ResponseStatus(code=HttpStatus.NOT_FOUND) annotation etc can be given to the class

we can send normal successfull response object also in response entity i think 
anyways if its error we can modify the response structure using the above class
	
	
ResponseEntityExceptionHandler -> class responsible for all the spring exceptions
When an exception is thrown , the response entity is returned by the ResponseEntityExceptionHandler class.
There is a handleException method which will return the response entity in many cases.
We can override this methode to return response entity if our type back .


@ControllerAdvice:
	variety of component annotation. valid across all controlllers
	
	
For documentation: Swagger
	it will give the swagger ui which will show all he rest apis and (http://localhost:8080/swagger-ui/index.html)
	Details of all the request response etc in a JSOn format also  (http://localhost:8080/v3/api-docs)
	
	
Content negotiation:
	The format(JSON or XML)  or the language(English , Malayalam)  the user want the response will be different
	This is configured in the request headers .header called"Accept"
	For this another format a dependancy is to be installed in pom
		groupid : com.fasterxml.jackson.dataformat
		artefact id : jackson-dataformat-xml 
	If dependancy is set and the Application/xml is given in request header
		The Object which is sent in the JSON will come in a xml format
	if we setup Accept: Application/xml in 
	
	
	
Internationalization:
	Accept-language header in the request .
	Getting the language from the header and ge tthe already configured message in java 
	
	
Versioning:
	Important when deploying an api to production etc.
	we can deploy another version of api and when the business is ready they cna start using the new vwersion 
	1.by url  ex: /v1/users , v2/users
	2.by request parameter
	3.by headers
	
	
